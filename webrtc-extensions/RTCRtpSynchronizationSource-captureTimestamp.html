<!doctype html>
<meta charset=utf-8>
<!-- This file contains a test that waits for 2 seconds. -->
<meta name="timeout" content="long">
<title>captureTimestamp attribute in RTCRtpSynchronizationSource</title>
<div><video id="remote" width="124" height="124" autoplay></video></div>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/webrtc/RTCPeerConnection-helper.js"></script>
<script src="/webrtc/RTCStats-helper.js"></script>
<script>
'use strict';

var kAbsCaptureTime =
    'http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time';

function addHeaderExtensionToSdp(sdp, uri) {
  const extmap = new RegExp('a=extmap:(\\d+)');
  let sdpLines = sdp.split('\r\n');

  for (const section of ['audio', 'video']) {
    let found_section = false;
    let maxId = undefined;
    let maxIdLine = undefined;
    let extmapAllowMixed = false;

    // find the largest header extension id for section.
    for (let i = 0; i < sdpLines.length; ++i) {
      if (!found_section) {
        if (sdpLines[i].startsWith('m=' + section)) {
          found_section = true;
        }
        continue;
      } else {
        if (sdpLines[i].startsWith('m=')) {
          // end of section
          break;
        }
      }

      if (sdpLines[i] === 'a=extmap-allow-mixed') {
        extmapAllowMixed = true;
      }
      let result = sdpLines[i].match(extmap);
      if (result && result.length === 2) {
        if (maxId == undefined || result[1] > maxId) {
          maxId = parseInt(result[1]);
          maxIdLine = i;
        }
      }
    }

    if (maxId == 14 && !extmapAllowMixed) {
      // Reaching the limit of one byte header extension. Adding two byte header
      // extension support.
      sdpLines.splice(maxIdLine + 1, 0, 'a=extmap-allow-mixed');
    }
    if (maxIdLine !== undefined) {
      sdpLines.splice(maxIdLine + 1, 0,
                      'a=extmap:' + (maxId + 1).toString() + ' ' + uri);
    }
  }
  return sdpLines.join('\r\n');
}

async function mungeAndExchangeOffer(caller, callee) {
  let offer = await caller.createOffer();

  // Absolute capture time header extension may not be offered by default,
  // in such case, munge the SDP.
  offer.sdp = addHeaderExtensionToSdp(offer.sdp, kAbsCaptureTime);

  await caller.setLocalDescription(offer);
  return callee.setRemoteDescription(offer);
}

async function exchangeOfferAndListenToOntrack(t, caller, callee,
                                               absCaptureTimeOffered) {
  const ontrackPromise = addEventListenerPromise(t, callee, 'track');
  // Absolute capture time header extension is expected not offered by default,
  // and thus munging is needed to enable it.
  await absCaptureTimeOffered ? mungeAndExchangeOffer(caller, callee)
                              : exchangeOffer(caller, callee);
  return ontrackPromise;
}

async function initiateSingleTrackCall(t, cap, absCaptureTimeNegotiated) {
  const caller = new RTCPeerConnection();
  t.add_cleanup(() => caller.close());
  const callee = new RTCPeerConnection();
  t.add_cleanup(() => callee.close());

  const stream = await getNoiseStream(cap);
  stream.getTracks().forEach(track => {
    caller.addTrack(track, stream);
    t.add_cleanup(() => track.stop());
  });

  // TODO(crbug.com/988432): `getSynchronizationSources() on the audio side
  // needs a hardware sink for the returned dictionary entries to get updated.
  const remoteVideo = document.getElementById('remote');

  callee.ontrack = e => {
    remoteVideo.srcObject = e.streams[0];
  }

  exchangeIceCandidates(caller, callee);

  await exchangeOfferAndListenToOntrack(t, caller, callee,
                                        absCaptureTimeNegotiated);

  // Absolute capture time header extension is expected answered when existing
  // in the offer from caller, and therefore no munging is needed on the answer.
  await exchangeAnswer(caller, callee);
  return [caller, callee];
}

// This test only passes if the implementation is sending the absolute capture
// timestamp header extension.
for (const kind of ['audio', 'video']) {
  for (const absCaptureTimeNegotiated of [true, false]) {
    promise_test(async t => {
      const [caller, callee] = await initiateSingleTrackCall(
          t, {[kind]: true}, absCaptureTimeNegotiated);
      const receiver = callee.getReceivers()[0];

      // Wait for 0.5 seconds so that absolute capture time header extension
      // must be received.
      await new Promise(resolve => t.step_timeout(resolve, 500));

      for (const ssrc of await listenForSSRCs(t, receiver)) {
        assert_equals(typeof ssrc.captureTimestamp,
                      absCaptureTimeNegotiated ? 'number' : 'undefined');
      }
    }, '[' + kind + '] getSynchronizationSources() should ' +
        (absCaptureTimeNegotiated ? '' : 'not ') +
        'contain captureTimestamp if absolute capture time header extension ' +
        'is ' + (absCaptureTimeNegotiated ? '' : 'not ') +
        'negotiated');
  }
}

promise_test(async t => {
  const [caller, callee] = await initiateSingleTrackCall(
      t, {audio: true, video: true}, true);
  const receivers = callee.getReceivers();
  assert_equals(receivers.length, 2);

  // Wait for 0.5 seconds so that absolute capture time header extension must be
  // received.
  await new Promise(resolve => t.step_timeout(resolve, 500));

  let captureTimestamps = [undefined, undefined];

  for (let i = 0; i < 2; ++i) {
    let ssrcs = await listenForSSRCs(t, receivers[i])
    assert_equals(ssrcs.length, 1);
    captureTimestamps[i] = ssrcs[0].captureTimestamp;
  }
  assert_true(Math.abs(captureTimestamps[0] - captureTimestamps[1]) <= 100);
}, 'Audio and video RTCRtpSynchronizationSource.captureTimestamp are ' +
   'comparable');

</script>
